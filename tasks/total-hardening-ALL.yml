# Required by zypper plugin
- name: ALL -> Check packages required by Ansible on SLES machines
  block:
    - name: ALL -> Check is python-xml installed on SLES servers
      command: rpm -q python-xml
      register: PYTHON_XML
      changed_when: false
      failed_when: false
    - name: ALL -> Install python-xml
      command: zypper in -y python-xml
      when: '"package python-xml is not installed" in PYTHON_XML.stdout'
      ignore_errors: true
      register: PYTHON_XML_INSTALL
    - name: ALL -> Report
      debug:
        msg: "Package python-xml required by Ansible zypper module is missing, please install it manually"
      when:
        - '"package python-xml is not installed" in PYTHON_XML.stdout'
        - PYTHON_XML_INSTALL.rc > 0
      failed_when: true
  when: ansible_os_family == "Suse"

- name: ALL -> Strictly forbidden filesystems
  block:
    - name: ALL -> Check if fat32 mounted
      shell: mount | awk '($5 == "fat32" ) { print $0 }'
      args:
       warn: false
      register: fat32check
      changed_when: false
      failed_when: false
    - name: ALL -> Report to user if fat32 is used
      debug:
        msg:
          - "Fat32 is forbidden filesystem. FIX THIS MANUALLY!!!"
          - "{{ fat32check.stdout }}"
      when: fat32check.stdout | length > 0
      failed_when: fat32check.stdout | length > 0
      ignore_errors: true

- name: ALL -> Setup session timeout for all users to {{ session_timeout_seconds }} seconds
  copy:
    dest: "/etc/profile.d/session-timeout-compliance.sh"
    mode: '0644'
    content: |
      TMOUT={{ session_timeout_seconds }}
      readonly TMOUT
      export TMOUT
  when: session_timeout_seconds|int > 0
  tags: SESSION_TIMEOUT

# Loop take longer, but we can better see what is removed
- name: ALL -> Remove unwanted packages from the system
  package:
    name: "{{ item }}"
    state: absent
  loop:
    - prelink
    - setroubleshoot
    - setroubleshoot-server
    - setroubleshoot-plugins
    - avahi
    - dhcp
    - openldap-servers
    - named
    - smb
    - nmb
    - squid
    - ypserv
    - rsh
    - ntalk
    - telnet-server
    - ypbind
    - talk
    - telnet
    - openldap-clients
    - mcstrans
    - rsh-server
    - libreswan
    - gcc
    - llvm
    - clang
    - open64
    - pcc
    - ntp
    - xinetd
  tags: PACKAGES_REMOVAL

- name: ALL -> Disable common unnecessary and dangerous services
  service:
    name: '{{ item }}'
    state: stopped
    enabled: no
  failed_when: false
  with_items:
    - xinetd
    - cups
    - cups.socket
    - cups-browsed
    - slapd
    - rsyncd
    - smb
    - smbd
    - anacron
    - bluetooth
    - hidd
    - hplip
    - irda
    - kdump
    - pcscd
    - readahead_early
    - readahead_later

- name: ALL -> Disable non-tftp services in xinetd.d
  replace: regexp="disable\s+=\s+[^yes]" replace="  disable = yes" dest=/etc/xinetd.d/{{ item }}
  with_items:
    - chargen-stream
    - chargen-dgram
    - daytime-dgram
    - daytime-stream
    - discard-dgram
    - discard-stream
    - echo-dgram
    - tcpmux-server
    - time-dgram
    - time-stream
  ignore_errors: true
  failed_when: false

- name: ALL -> Remove httpd if system is not web server
  package:
    name: httpd
    state: absent
  when: not system_is_webserver

- name: ALL -> Disable automounting
  service:
    name: autofs
    enabled: no
    state: stopped
  failed_when: false

- name: ALL -> Remove vsftpd and tftp if system is not ftp server
  package:
    name:
      - vsftpd
      - tftp
    state: absent
  when: not system_is_ftp

- name: ALL -> Remove dovecot if system is not mail server
  package:
    name: dovecot
    state: absent
  when: not system_is_mailserver

- name: ALL -> Install common packages
  package:
    name:
      - logrotate
      - man
      - vim
      - chrony
      - audit
      - audit-libs
      - lsof
      - cracklib
      - sysstat
      - postfix
      - rsyslog
      - cronie
      - polkit
    state: present
  tags:
    - COMMON_PACKAGES
    - SETUP_PROC_MOUNT

- name: ALL -> Update all packages to the latest version
  package:
    name: '*'
    state: latest

- name: ALL -> Start and enable sysstat service
  service:
    name: sysstat
    state: started
    enabled: yes

- name: ALL -> Check and setup partition --> /tmp
  block:
    - name: ALL -> Setup partition flag
      set_fact:
        partition_name: "/tmp"
    - name: ALL -> Check if {{ partition_name }} is currently supported by this hardening
      shell: mount | grep " {{ partition_name }} " | grep "ext3\|ext4\|xfs"
      args:
       warn: false
      register: tmp_mount_check_fs
      changed_when: false
      failed_when: false
    - name: ALL -> Check if {{ partition_name }} is separate partition
      shell: mount | grep " {{ partition_name }} "
      args:
       warn: false
      register: tmp_mount_check_separate
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount device
      shell: awk '($2 == "{{ partition_name }}" ) { print $1 }' /etc/fstab
      register: tmp_mount_check_device
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} filesystem from fstab
      shell: awk '($2 == "{{ partition_name }}" ) { print $3 }' /etc/fstab
      register: tmp_mount_check_fs_fstab
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount options
      shell: awk '($2 == "{{ partition_name }}" ) { print $4 }' /etc/fstab
      register: tmp_mount_check_options
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} dump option
      shell: awk '($2 == "{{ partition_name }}" ) { print $5 }' /etc/fstab
      register: tmp_mount_check_dump
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} passno option
      shell: awk '($2 == "{{ partition_name }}" ) { print $6 }' /etc/fstab
      register: tmp_mount_check_passno
      changed_when: false
      failed_when: false
    - name: ALL -> Report to user when {{ partition_name }} is not separate or fs is not yet supported
      debug:
        msg:
          - "Partition is not separate or filesystem is not yet supported"
          - "Please FIX THIS MANUALLY for {{ partition_name }}"
          - "tmp_mount_check_fs - {{ var_mount_check_fs.stdout }}"
          - "tmp_mount_check_separate - {{ var_mount_check_separate.stdout }}"
          - "tmp_mount_check_device - {{ var_mount_check_device.stdout }}"
          - "tmp_mount_check_fs_fstab - {{ var_mount_check_fs_fstab.stdout }}"
          - "tmp_mount_check_options - {{ var_mount_check_options.stdout }}"
          - "tmp_mount_check_dump - {{ var_mount_check_dump.stdout }}"
          - "tmp_mount_check_passno - {{ var_mount_check_passno.stdout }}"
      when: >
        tmp_mount_check_fs.stdout | length == 0 or
        tmp_mount_check_separate.stdout | length == 0 or
        tmp_mount_check_fs_fstab.stdout | length == 0
      failed_when: true
      ignore_errors: true
    - name: ALL -> Setup {{ partition_name }} partition
      block:
        - name: ALL -> Set clean partition fact
          set_fact:
            tmp_mount_flags: "{{ tmp_mount_check_options.stdout }}"
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nodev
          set_fact:
            tmp_mount_flags: "{{ tmp_mount_flags }},nodev"
          when: '"nodev" not in tmp_mount_flags'
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nosuid
          set_fact:
            tmp_mount_flags: "{{ tmp_mount_flags }},nosuid"
          when: '"nosuid" not in tmp_mount_flags'
          changed_when: false
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> noexec
          set_fact:
            tmp_mount_flags: "{{ tmp_mount_flags }},noexec"
          when: '"noexec" not in tmp_mount_flags'
          changed_when: false
        - name: ALL -> Add to {{ partition_name }} missing mount option(s) and remount
          mount:
            name: '{{ partition_name }}'
            src: '{{ tmp_mount_check_device.stdout }}'
            state: mounted
            fstype: '{{ tmp_mount_check_fs_fstab.stdout }}'
            opts: "{{ tmp_mount_flags }}"
            dump: '{{ tmp_mount_check_dump.stdout }}'
            passno: '{{ tmp_mount_check_passno.stdout }}'
            backup: yes
      when:
        - tmp_mount_check_separate.stdout | length > 0
        - tmp_mount_check_fs.stdout | length > 0
        - tmp_mount_check_fs_fstab.stdout | length > 0
  tags: SETUP_TMP_PARTITION

- name: ALL -> Check and setup partition --> /var
  block:
    - name: ALL -> Setup partition flag
      set_fact:
        partition_name: "/var"
    - name: ALL -> Check if {{ partition_name }} is currently supported by this hardening
      shell: mount | grep " {{ partition_name }} " | grep "ext3\|ext4\|xfs"
      args:
       warn: false
      register: var_mount_check_fs
      changed_when: false
      failed_when: false
    - name: ALL -> Check if {{ partition_name }} is separate partition
      shell: mount | grep " {{ partition_name }} "
      args:
       warn: false
      register: var_mount_check_separate
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount device
      shell: awk '($2 == "{{ partition_name }}" ) { print $1 }' /etc/fstab
      register: var_mount_check_device
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} filesystem from fstab
      shell: awk '($2 == "{{ partition_name }}" ) { print $3 }' /etc/fstab
      register: var_mount_check_fs_fstab
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount options
      shell: awk '($2 == "{{ partition_name }}" ) { print $4 }' /etc/fstab
      register: var_mount_check_options
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} dump option
      shell: awk '($2 == "{{ partition_name }}" ) { print $5 }' /etc/fstab
      register: var_mount_check_dump
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} passno option
      shell: awk '($2 == "{{ partition_name }}" ) { print $6 }' /etc/fstab
      register: var_mount_check_passno
      changed_when: false
      failed_when: false
    - name: ALL -> Report to user when {{ partition_name }} is not separate or fs is not yet supported
      debug:
        msg:
          - "Partition is not separate or filesystem is not yet supported"
          - "Please FIX THIS MANUALLY for {{ partition_name }}"
          - "var_mount_check_fs - {{ var_mount_check_fs.stdout }}"
          - "var_mount_check_separate - {{ var_mount_check_separate.stdout }}"
          - "var_mount_check_device - {{ var_mount_check_device.stdout }}"
          - "var_mount_check_fs_fstab - {{ var_mount_check_fs_fstab.stdout }}"
          - "var_mount_check_options - {{ var_mount_check_options.stdout }}"
          - "var_mount_check_dump - {{ var_mount_check_dump.stdout }}"
          - "var_mount_check_passno - {{ var_mount_check_passno.stdout }}"
      when: >
        var_mount_check_fs.stdout | length == 0 or
        var_mount_check_separate.stdout | length == 0 or
        var_mount_check_fs_fstab.stdout | length == 0
      failed_when: true
      ignore_errors: true
    - name: ALL -> Setup {{ partition_name }} partition
      block:
        - name: ALL -> Set clean partition fact
          set_fact:
            var_mount_flags: "{{ var_mount_check_options.stdout }}"
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nodev
          set_fact:
            var_mount_flags: "{{ var_mount_flags }},nodev"
          when: '"nodev" not in var_mount_flags'
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nosuid
          set_fact:
            var_mount_flags: "{{ var_mount_flags }},nosuid"
          when: '"nosuid" not in var_mount_flags'
          changed_when: false
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> noexec
          set_fact:
            var_mount_flags: "{{ var_mount_flags }},noexec"
          when: '"noexec" not in var_mount_flags'
          changed_when: false
        - name: ALL -> Add to {{ partition_name }} missing mount option(s) and remount
          mount:
            name: '{{ partition_name }}'
            src: '{{ var_mount_check_device.stdout }}'
            state: mounted
            fstype: '{{ var_mount_check_fs_fstab.stdout }}'
            opts: "{{ var_mount_flags }}"
            dump: '{{ var_mount_check_dump.stdout }}'
            passno: '{{ var_mount_check_passno.stdout }}'
            backup: yes
      when:
        - var_mount_check_separate.stdout | length > 0
        - var_mount_check_fs.stdout | length > 0
        - var_mount_check_fs_fstab.stdout | length > 0
  tags: SETUP_VAR_PARTITION

- name: ALL -> Check and setup partition --> /var/tmp
  block:
    - name: ALL -> Setup partition flag
      set_fact:
        partition_name: "/var/tmp"
    - name: ALL -> Check if {{ partition_name }} is currently supported by this hardening
      shell: mount | grep " {{ partition_name }} " | grep "ext3\|ext4\|xfs"
      args:
       warn: false
      register: vartmp_mount_check_fs
      changed_when: false
      failed_when: false
    - name: ALL -> Check if {{ partition_name }} is separate partition
      shell: mount | grep " {{ partition_name }} "
      args:
       warn: false
      register: vartmp_mount_check_separate
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount device
      shell: awk '($2 == "{{ partition_name }}" ) { print $1 }' /etc/fstab
      register: vartmp_mount_check_device
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} filesystem from fstab
      shell: awk '($2 == "{{ partition_name }}" ) { print $3 }' /etc/fstab
      register: vartmp_mount_check_fs_fstab
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount options
      shell: awk '($2 == "{{ partition_name }}" ) { print $4 }' /etc/fstab
      register: vartmp_mount_check_options
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} dump option
      shell: awk '($2 == "{{ partition_name }}" ) { print $5 }' /etc/fstab
      register: vartmp_mount_check_dump
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} passno option
      shell: awk '($2 == "{{ partition_name }}" ) { print $6 }' /etc/fstab
      register: vartmp_mount_check_passno
      changed_when: false
      failed_when: false
    - name: ALL -> Report to user when {{ partition_name }} is not separate or fs is not yet supported
      debug:
        msg:
          - "Partition is not separate or filesystem is not yet supported"
          - "Please FIX THIS MANUALLY for {{ partition_name }}"
          - "vartmp_mount_check_fs - {{ var_mount_check_fs.stdout }}"
          - "vartmp_mount_check_separate - {{ var_mount_check_separate.stdout }}"
          - "vartmp_mount_check_device - {{ var_mount_check_device.stdout }}"
          - "vartmp_mount_check_fs_fstab - {{ var_mount_check_fs_fstab.stdout }}"
          - "vartmp_mount_check_options - {{ var_mount_check_options.stdout }}"
          - "vartmp_mount_check_dump - {{ var_mount_check_dump.stdout }}"
          - "vartmp_mount_check_passno - {{ var_mount_check_passno.stdout }}"
      when: >
        vartmp_mount_check_fs.stdout | length == 0 or
        vartmp_mount_check_separate.stdout | length == 0 or
        vartmp_mount_check_fs_fstab.stdout | length == 0
      failed_when: true
      ignore_errors: true
    - name: ALL -> Setup {{ partition_name }} partition
      block:
        - name: ALL -> Set clean partition fact
          set_fact:
            vartmp_mount_flags: "{{ vartmp_mount_check_options.stdout }}"
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nodev
          set_fact:
            vartmp_mount_flags: "{{ vartmp_mount_flags }},nodev"
          when: '"nodev" not in vartmp_mount_flags'
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nosuid
          set_fact:
            vartmp_mount_flags: "{{ vartmp_mount_flags }},nosuid"
          when: '"nosuid" not in vartmp_mount_flags'
          changed_when: false
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> noexec
          set_fact:
            vartmp_mount_flags: "{{ vartmp_mount_flags }},noexec"
          when: '"noexec" not in vartmp_mount_flags'
          changed_when: false
        - name: ALL -> Add to {{ partition_name }} missing mount option(s) and remount
          mount:
            name: '{{ partition_name }}'
            src: '{{ vartmp_mount_check_device.stdout }}'
            state: mounted
            fstype: '{{ vartmp_mount_check_fs_fstab.stdout }}'
            opts: "{{ vartmp_mount_flags }}"
            dump: '{{ vartmp_mount_check_dump.stdout }}'
            passno: '{{ vartmp_mount_check_passno.stdout }}'
            backup: yes
      when:
        - vartmp_mount_check_separate.stdout | length > 0
        - vartmp_mount_check_fs.stdout | length > 0
        - vartmp_mount_check_fs_fstab.stdout | length > 0
  tags: SETUP_VAR_PARTITION

- name: ALL -> Check and setup partition --> /var/log
  block:
    - name: ALL -> Setup partition flag
      set_fact:
        partition_name: "/var/log"
    - name: ALL -> Check if {{ partition_name }} is currently supported by this hardening
      shell: mount | grep " {{ partition_name }} " | grep "ext3\|ext4\|xfs"
      args:
       warn: false
      register: varlog_mount_check_fs
      changed_when: false
      failed_when: false
    - name: ALL -> Check if {{ partition_name }} is separate partition
      shell: mount | grep " {{ partition_name }} "
      args:
       warn: false
      register: varlog_mount_check_separate
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount device
      shell: awk '($2 == "{{ partition_name }}" ) { print $1 }' /etc/fstab
      register: varlog_mount_check_device
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} filesystem from fstab
      shell: awk '($2 == "{{ partition_name }}" ) { print $3 }' /etc/fstab
      register: varlog_mount_check_fs_fstab
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount options
      shell: awk '($2 == "{{ partition_name }}" ) { print $4 }' /etc/fstab
      register: varlog_mount_check_options
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} dump option
      shell: awk '($2 == "{{ partition_name }}" ) { print $5 }' /etc/fstab
      register: varlog_mount_check_dump
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} passno option
      shell: awk '($2 == "{{ partition_name }}" ) { print $6 }' /etc/fstab
      register: varlog_mount_check_passno
      changed_when: false
      failed_when: false
    - name: ALL -> Report to user when {{ partition_name }} is not separate or fs is not yet supported
      debug:
        msg:
          - "Partition is not separate or filesystem is not yet supported"
          - "Please FIX THIS MANUALLY for {{ partition_name }}"
          - "varlog_mount_check_fs - {{ var_mount_check_fs.stdout }}"
          - "varlog_mount_check_separate - {{ var_mount_check_separate.stdout }}"
          - "varlog_mount_check_device - {{ var_mount_check_device.stdout }}"
          - "varlog_mount_check_fs_fstab - {{ var_mount_check_fs_fstab.stdout }}"
          - "varlog_mount_check_options - {{ var_mount_check_options.stdout }}"
          - "varlog_mount_check_dump - {{ var_mount_check_dump.stdout }}"
          - "varlog_mount_check_passno - {{ var_mount_check_passno.stdout }}"
      when: >
        varlog_mount_check_fs.stdout | length == 0 or
        varlog_mount_check_separate.stdout | length == 0 or
        varlog_mount_check_fs_fstab.stdout | length == 0
      failed_when: true
      ignore_errors: true
    - name: ALL -> Setup {{ partition_name }} partition
      block:
        - name: ALL -> Set clean partition fact
          set_fact:
            varlog_mount_flags: "{{ varlog_mount_check_options.stdout }}"
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nodev
          set_fact:
            varlog_mount_flags: "{{ varlog_mount_flags }},nodev"
          when: '"nodev" not in varlog_mount_flags'
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nosuid
          set_fact:
            varlog_mount_flags: "{{ varlog_mount_flags }},nosuid"
          when: '"nosuid" not in varlog_mount_flags'
          changed_when: false
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> noexec
          set_fact:
            varlog_mount_flags: "{{ varlog_mount_flags }},noexec"
          when: '"noexec" not in varlog_mount_flags'
          changed_when: false
        - name: ALL -> Add to {{ partition_name }} missing mount option(s) and remount
          mount:
            name: '{{ partition_name }}'
            src: '{{ varlog_mount_check_device.stdout }}'
            state: mounted
            fstype: '{{ varlog_mount_check_fs_fstab.stdout }}'
            opts: "{{ varlog_mount_flags }}"
            dump: '{{ varlog_mount_check_dump.stdout }}'
            passno: '{{ varlog_mount_check_passno.stdout }}'
            backup: yes
      when:
        - varlog_mount_check_separate.stdout | length > 0
        - varlog_mount_check_fs.stdout | length > 0
        - varlog_mount_check_fs_fstab.stdout | length > 0
  tags: SETUP_VAR_LOG_PARTITION

- name: ALL -> Check and setup partition --> /var/log/audit
  block:
    - name: ALL -> Setup partition flag
      set_fact:
        partition_name: "/var/log/audit"
    - name: ALL -> Check if {{ partition_name }} is currently supported by this hardening
      shell: mount | grep " {{ partition_name }} " | grep "ext3\|ext4\|xfs"
      args:
       warn: false
      register: varlogaudit_mount_check_fs
      changed_when: false
      failed_when: false
    - name: ALL -> Check if {{ partition_name }} is separate partition
      shell: mount | grep " {{ partition_name }} "
      args:
       warn: false
      register: varlogaudit_mount_check_separate
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount device
      shell: awk '($2 == "{{ partition_name }}" ) { print $1 }' /etc/fstab
      register: varlogaudit_mount_check_device
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} filesystem from fstab
      shell: awk '($2 == "{{ partition_name }}" ) { print $3 }' /etc/fstab
      register: varlogaudit_mount_check_fs_fstab
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount options
      shell: awk '($2 == "{{ partition_name }}" ) { print $4 }' /etc/fstab
      register: varlogaudit_mount_check_options
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} dump option
      shell: awk '($2 == "{{ partition_name }}" ) { print $5 }' /etc/fstab
      register: varlogaudit_mount_check_dump
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} passno option
      shell: awk '($2 == "{{ partition_name }}" ) { print $6 }' /etc/fstab
      register: varlogaudit_mount_check_passno
      changed_when: false
      failed_when: false
    - name: ALL -> Report to user when {{ partition_name }} is not separate or fs is not yet supported
      debug:
        msg:
          - "Partition is not separate or filesystem is not yet supported"
          - "Please FIX THIS MANUALLY for {{ partition_name }}"
          - "varlogaudit_mount_check_fs - {{ var_mount_check_fs.stdout }}"
          - "varlogaudit_mount_check_separate - {{ var_mount_check_separate.stdout }}"
          - "varlogaudit_mount_check_device - {{ var_mount_check_device.stdout }}"
          - "varlogaudit_mount_check_fs_fstab - {{ var_mount_check_fs_fstab.stdout }}"
          - "varlogaudit_mount_check_options - {{ var_mount_check_options.stdout }}"
          - "varlogaudit_mount_check_dump - {{ var_mount_check_dump.stdout }}"
          - "varlogaudit_mount_check_passno - {{ var_mount_check_passno.stdout }}"
      when: >
        varlogaudit_mount_check_fs.stdout | length == 0 or
        varlogaudit_mount_check_separate.stdout | length == 0 or
        varlogaudit_mount_check_fs_fstab.stdout | length == 0
      failed_when: true
      ignore_errors: true
    - name: ALL -> Setup {{ partition_name }} partition
      block:
        - name: ALL -> Set clean partition fact
          set_fact:
            varlogaudit_mount_flags: "{{ varlogaudit_mount_check_options.stdout }}"
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nodev
          set_fact:
            varlogaudit_mount_flags: "{{ varlogaudit_mount_flags }},nodev"
          when: '"nodev" not in varlogaudit_mount_flags'
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nosuid
          set_fact:
            varlogaudit_mount_flags: "{{ varlogaudit_mount_flags }},nosuid"
          when: '"nosuid" not in varlogaudit_mount_flags'
          changed_when: false
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> noexec
          set_fact:
            varlogaudit_mount_flags: "{{ varlogaudit_mount_flags }},noexec"
          when: '"noexec" not in varlogaudit_mount_flags'
          changed_when: false
        - name: ALL -> Add to {{ partition_name }} missing mount option(s) and remount
          mount:
            name: '{{ partition_name }}'
            src: '{{ varlogaudit_mount_check_device.stdout }}'
            state: mounted
            fstype: '{{ varlogaudit_mount_check_fs_fstab.stdout }}'
            opts: "{{ varlogaudit_mount_flags }}"
            dump: '{{ varlogaudit_mount_check_dump.stdout }}'
            passno: '{{ varlogaudit_mount_check_passno.stdout }}'
            backup: yes
      when:
        - varlogaudit_mount_check_separate.stdout | length > 0
        - varlogaudit_mount_check_fs.stdout | length > 0
        - varlogaudit_mount_check_fs_fstab.stdout | length > 0
  tags: SETUP_VAR_LOG_PARTITION

- name: ALL -> Check and setup partition --> /home
  block:
    - name: ALL -> Setup partition flag
      set_fact:
        partition_name: "/home"
    - name: ALL -> Check if {{ partition_name }} is currently supported by this hardening
      shell: mount | grep " {{ partition_name }} " | grep "ext3\|ext4\|xfs"
      args:
       warn: false
      register: home_mount_check_fs
      changed_when: false
      failed_when: false
    - name: ALL -> Check if {{ partition_name }} is separate partition
      shell: mount | grep " {{ partition_name }} "
      args:
       warn: false
      register: home_mount_check_separate
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount device
      shell: awk '($2 == "{{ partition_name }}" ) { print $1 }' /etc/fstab
      register: home_mount_check_device
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} filesystem from fstab
      shell: awk '($2 == "{{ partition_name }}" ) { print $3 }' /etc/fstab
      register: home_mount_check_fs_fstab
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount options
      shell: awk '($2 == "{{ partition_name }}" ) { print $4 }' /etc/fstab
      register: home_mount_check_options
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} dump option
      shell: awk '($2 == "{{ partition_name }}" ) { print $5 }' /etc/fstab
      register: home_mount_check_dump
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} passno option
      shell: awk '($2 == "{{ partition_name }}" ) { print $6 }' /etc/fstab
      register: home_mount_check_passno
      changed_when: false
      failed_when: false
    - name: ALL -> Report to user when {{ partition_name }} is not separate or fs is not yet supported
      debug:
        msg:
          - "Partition is not separate or filesystem is not yet supported"
          - "Please FIX THIS MANUALLY for {{ partition_name }}"
          - "home_mount_check_fs - {{ var_mount_check_fs.stdout }}"
          - "home_mount_check_separate - {{ var_mount_check_separate.stdout }}"
          - "home_mount_check_device - {{ var_mount_check_device.stdout }}"
          - "home_mount_check_fs_fstab - {{ var_mount_check_fs_fstab.stdout }}"
          - "home_mount_check_options - {{ var_mount_check_options.stdout }}"
          - "home_mount_check_dump - {{ var_mount_check_dump.stdout }}"
          - "home_mount_check_passno - {{ var_mount_check_passno.stdout }}"
      when: >
        home_mount_check_fs.stdout | length == 0 or
        home_mount_check_separate.stdout | length == 0 or
        home_mount_check_fs_fstab.stdout | length == 0
      failed_when: true
      ignore_errors: true
    - name: ALL -> Setup {{ partition_name }} partition
      block:
        - name: ALL -> Set clean partition fact
          set_fact:
            home_mount_flags: "{{ home_mount_check_options.stdout }}"
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nodev
          set_fact:
            home_mount_flags: "{{ home_mount_flags }},nodev"
          when: '"nodev" not in home_mount_flags'
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nosuid
          set_fact:
            home_mount_flags: "{{ home_mount_flags }},nosuid"
          when: '"nosuid" not in home_mount_flags'
          changed_when: false
        - name: ALL -> Add to {{ partition_name }} missing mount option(s) and remount
          mount:
            name: '{{ partition_name }}'
            src: '{{ home_mount_check_device.stdout }}'
            state: mounted
            fstype: '{{ home_mount_check_fs_fstab.stdout }}'
            opts: "{{ home_mount_flags }}"
            dump: '{{ home_mount_check_dump.stdout }}'
            passno: '{{ home_mount_check_passno.stdout }}'
            backup: yes
      when:
        - home_mount_check_separate.stdout | length > 0
        - home_mount_check_fs.stdout | length > 0
        - home_mount_check_fs_fstab.stdout | length > 0
  tags: SETUP_HOME_PARTITION

- name: ALL -> Check and setup partition --> /boot
  block:
    - name: ALL -> Setup partition flag
      set_fact:
        partition_name: "/boot"
    - name: ALL -> Check if {{ partition_name }} is currently supported by this hardening
      shell: mount | grep " {{ partition_name }} " | grep "ext3\|ext4\|xfs"
      args:
       warn: false
      register: boot_mount_check_fs
      changed_when: false
      failed_when: false
    - name: ALL -> Check if {{ partition_name }} is separate partition
      shell: mount | grep " {{ partition_name }} "
      args:
       warn: false
      register: boot_mount_check_separate
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount device
      shell: awk '($2 == "{{ partition_name }}" ) { print $1 }' /etc/fstab
      register: boot_mount_check_device
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} filesystem from fstab
      shell: awk '($2 == "{{ partition_name }}" ) { print $3 }' /etc/fstab
      register: boot_mount_check_fs_fstab
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} mount options
      shell: awk '($2 == "{{ partition_name }}" ) { print $4 }' /etc/fstab
      register: boot_mount_check_options
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} dump option
      shell: awk '($2 == "{{ partition_name }}" ) { print $5 }' /etc/fstab
      register: boot_mount_check_dump
      changed_when: false
      failed_when: false
    - name: ALL -> Get {{ partition_name }} passno option
      shell: awk '($2 == "{{ partition_name }}" ) { print $6 }' /etc/fstab
      register: boot_mount_check_passno
      changed_when: false
      failed_when: false
    - name: ALL -> Report to user when {{ partition_name }} is not separate or fs is not yet supported
      debug:
        msg:
          - "Partition is not separate or filesystem is not yet supported"
          - "Please FIX THIS MANUALLY for {{ partition_name }}"
          - "boot_mount_check_fs - {{ var_mount_check_fs.stdout }}"
          - "boot_mount_check_separate - {{ var_mount_check_separate.stdout }}"
          - "boot_mount_check_device - {{ var_mount_check_device.stdout }}"
          - "boot_mount_check_fs_fstab - {{ var_mount_check_fs_fstab.stdout }}"
          - "boot_mount_check_options - {{ var_mount_check_options.stdout }}"
          - "boot_mount_check_dump - {{ var_mount_check_dump.stdout }}"
          - "boot_mount_check_passno - {{ var_mount_check_passno.stdout }}"
      when: >
        boot_mount_check_fs.stdout | length == 0 or
        boot_mount_check_separate.stdout | length == 0 or
        boot_mount_check_fs_fstab.stdout | length == 0
      failed_when: true
      ignore_errors: true
    - name: ALL -> Setup {{ partition_name }} partition
      block:
        - name: ALL -> Set clean partition fact
          set_fact:
            boot_mount_flags: "{{ boot_mount_check_options.stdout }}"
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nodev
          set_fact:
            boot_mount_flags: "{{ boot_mount_flags }},nodev"
          when: '"nodev" not in boot_mount_flags'
        - name: ALL -> Set flag if {{ partition_name }} does not have option --> nosuid
          set_fact:
            boot_mount_flags: "{{ boot_mount_flags }},nosuid"
          when: '"nosuid" not in boot_mount_flags'
          changed_when: false
        - name: ALL -> Add to {{ partition_name }} missing mount option(s) and remount
          mount:
            name: '{{ partition_name }}'
            src: '{{ boot_mount_check_device.stdout }}'
            state: mounted
            fstype: '{{ boot_mount_check_fs_fstab.stdout }}'
            opts: "{{ boot_mount_flags }}"
            dump: '{{ boot_mount_check_dump.stdout }}'
            passno: '{{ boot_mount_check_passno.stdout }}'
            backup: yes
      when:
        - boot_mount_check_separate.stdout | length > 0
        - boot_mount_check_fs.stdout | length > 0
        - boot_mount_check_fs_fstab.stdout | length > 0
  tags: SETUP_BOOT_PARTITION

# Users will not be able to see processes of the other users. Root can see the all.
- name: ALL -> Set hidepid=2 in /etc/fstab so users cannot see pids of other users
  block:
    - name: ALL -> Set hidepid=2 in /etc/fstab so users cannot see pids of other users
      mount:
        path: /proc
        src: proc
        fstype: proc
        opts: defaults,hidepid=2,gid=nohidproc
        passno: "0"
        dump: "0"
        state: present
      register: hidepid
    - name: ALL -> Ensure group "nohidproc" exists - needed for hidepid
      group:
        name: nohidproc
        state: present
        gid: 23
    - name: ALL -> Add the group nohidproc as a secondary to polkitd
      user:
        name: polkitd
        groups: nohidproc
        append: yes
    - name: ALL -> Remount /proc if changed in fstab
      mount:
        path: /proc
        opts: defaults,hidepid=2,gid=nohidproc
        state: remounted
      when: hidepid.changed
    - name: ALL -> Restart polkit service
      service:
        name: 'polkit'
        state: restarted
      when: hidepid.changed
  tags: SETUP_PROC_MOUNT

- name: ALL -> Setup flags on /dev/shm partition
  mount:
    path: /dev/shm
    src: tmpfs
    fstype: tmpfs
    opts: rw,nosuid,nodev,seclabel,noexec
    dump: "0"
    passno: "0"
    state: present

- name: ALL -> Reformat content of /etc/fstab
  block:
    - name: ALL -> Create normal output for fstab to /tmp/fstab.temp
      shell: grep -v '^#' /etc/fstab | column -t > /tmp/fstab.temp
      changed_when: false
    - name: ALL -> Diff original and formatted fstab
      command: diff /tmp/fstab.temp /etc/fstab
      changed_when: false
      failed_when: false
      register: fstab_diff
    - name: ALL -> Backup original /etc/fstab
      shell: cat /etc/fstab > /tmp/fstab-original
      changed_when: false
      when: fstab_diff.stdout | length > 0
    - name: ALL -> Apply /tmp/fstab.temp to /etc/fstab
      copy:
        src: /tmp/fstab.temp
        dest: /etc/fstab
        remote_src: yes
        mode: "0644"
      register: fstab_reformat
      when: fstab_diff.stdout | length > 0
    - name: ALL -> Delete /tmp/fstab.temp
      file:
        path: /tmp/fstab.temp
        state: absent
      changed_when: false
      when: fstab_diff.stdout | length > 0
  tags: REFORMAT_FSTAB

- name: ALL -> Search /var/log/messages to see if protection is active
  block:
    - name: ALL -> Search /var/log/messages to see if protection is active
      shell: |
        grep ^flags /proc/cpuinfo | head -n1 | grep -c 'nx'
      register: nx_protection
      changed_when: false
    - name: ALL -> Report
      debug: msg='Enable XD/NX support from BIOS manually {{ nx_protection.stdout|int }}'
      when: nx_protection.stdout|int == 0
      changed_when: true

- name: ALL -> Setup chrony on all systems
  block:
  - name: ALL -> Configure chrony
    template:
      src: "files/chrony.conf"
      dest: /etc/chrony.conf
      owner: root
      group: root
      mode: 0644
  - name: ALL -> Verify chrony is started and enabled
    service:
      name: chronyd
      state: started
      enabled: yes

# Require postfix installed (done tags=COMMON_PACKAGES)
- name: ALL -> Configure email for local-only mode if mail software is installed and not intending to be an external email relay #mail_server=false)
  block:
    - name: ALL -> Find do we have a mail agent config file
      stat:
        path: /etc/postfix/main.cf
      register: postfix_out
      changed_when: false
    - name: ALL -> If the file exists and not a mail server, then set loopback only
      lineinfile:
        path: /etc/postfix/main.cf
        regexp:  "{{ item.regexp }}"
        line: "{{ item.line }}"
        backup: yes
      with_items:
        - { regexp: "^.*inet_interfaces = ", line: "inet_interfaces = loopback-only" }
        - { regexp: "^.*smtpd_banner = ", line: "smtpd_banner = $myhostname ESMTP" }
        - { regexp: "^.*inet_protocols = ", line: "inet_protocols = ipv4" }
      when: postfix_out.stat.exists
      register: main_cf
    - name: ALL -> Restart service postfix if main.cf is changed
      service:
        name: postfix
        state: restarted
      when: main_cf.changed
    - name: ALL -> Test postfix config
      command: postconf > /dev/null
      when: main_cf.changed
      changed_when: false
  when: not system_is_mailserver

- name: ALL -> Ensure permissions on /etc/crontab
  file:
    path: /etc/crontab
    owner: root
    group: root
    mode: 0600

- name: ALL -> Ensure permissions on crontab directories
  file:
    path: "{{ item }}"
    owner: root
    group: root
    mode: 0700
  loop:
      - /etc/cron.hourly
      - /etc/cron.daily
      - /etc/cron.weekly
      - /etc/cron.monthly
      - /etc/cron.d

- name: ALL -> Create the cron/at allow files
  copy:
    dest: "{{ item }}"
    content: ""
    force: no
    owner: root
    group: root
    mode: 0600
  with_items:
    - /etc/cron.allow
    - /etc/at.allow

# Please correct this manually if check find something.
- name: ALL -> Ensure no world writable files exist
  block:
    - name: ALL -> Find any world writable files
      shell: "/usr/bin/df --local -P | /usr/bin/awk {' if (NR!=1) print $6'} | /usr/bin/xargs -I '{}' find '{}' -xdev -type f -perm -0002"
      register: ww_files
      changed_when: false
    - name: ALL -> Print any world writable files found (fix manually if any)
      debug:
        msg: "World writable files found: {{ ww_files.stdout }}"
      changed_when: true
      when: ww_files.stdout

- name: ALL -> Ensure no unowned files exist
  block:
    - name: ALL -> Find any unowned files
      shell: "/usr/bin/df --local -P | /usr/bin/awk {' if (NR!=1) print $6'} | /usr/bin/xargs -I '{}' find '{}' -xdev -nouser"
      register: uo_files
      changed_when: false
    - name: ALL -> Print any unowned files found
      debug:
        msg: "Unowned files found: {{ uo_files.stdout_lines }}"
      changed_when: true
      when: uo_files.stdout

- name: ALL -> Ensure no ungrouped files exist
  block:
    - name: ALL -> Find any ungrouped files
      shell: "/usr/bin/df --local -P | /usr/bin/awk {' if (NR!=1) print $6'} | /usr/bin/xargs -I '{}' find '{}' -xdev -nogroup"
      register: ug_files
      changed_when: false
    - name: ALL -> Print any ungrouped files found (fix manually if any)
      debug:
        msg: "ungrouped files found: {{ uo_files.stdout_lines }}"
      changed_when: true
      when: ug_files.stdout

- name: ALL -> Ensure password fields are not empty
  block:
    - name: ALL -> Check to see if there are any accounts with empty passwords
      shell: "/usr/bin/cat /etc/shadow | awk -F: '($2 == \"\" ) { print $1 }'"
      changed_when: false
      register: empty_passwords
    - name: ALL -> Report the named users to the report (fix manually if any)
      debug:
        msg: "The user {{ item }} has an empty password"
      when: empty_passwords.stdout
      changed_when: true
      loop: "{{ empty_passwords.stdout_lines }}"

- name: ALL -> Ensure root PATH integrity
  block:
    - name: ALL -> Run script on path variable
      shell: |
        if [ "$(echo $PATH | grep ::)" != "" ]; then
            echo "Empty Directory in PATH (::)"
        fi
        if [ "$(echo $PATH | grep :$)" != "" ]; then
            echo "Trailing : in PATH"
        fi
        p=$(echo $PATH | sed -e 's/::/:/' -e 's/:$//' -e 's/:/ /g')
        set -- $p
        while [ "$1" != "" ]; do
            if [ "$1" = "." ]; then
                echo "PATH contains ."
                shift
                continue
            fi
            if [ -d $1 ]; then
                dirperm=$(ls -ldH $1 | cut -f1 -d" ")
                if [ "$(echo $dirperm | cut -c6)" != "-" ]; then
                    echo "Group Write permission set on directory $1"
                fi
                if [ "$(echo $dirperm | cut -c9)" != "-" ]; then
                echo "Other Write permission set on directory $1"
                fi
                dirown=$(ls -ldH $1 | awk '{print $3}')
                if [ "$dirown" != "root" ] ; then
                    echo $1 is not owned by root
                fi
            else
                echo $1 is not a directory
            fi
            shift
        done
      changed_when: false
      failed_when: false
      register: path_check
    - name: ALL -> Print report to user (fix manually if any)
      debug:
        msg:
          - "Note, Ansible runs this as SUDO with the ansible user's PATH variable. The script may not print issues"
          - "that exist in root's path because of this. It should be run as root on the target machine manually."
          - " {{ path_check.stdout }}"
      when: path_check.stdout

- name: ALL -> Report on groups in /etc/passwd with a GID not in /etc/group
  block:
    - name: ALL -> Use script to pull the list of groups
      shell: |
        for i in $(cut -s -d: -f4 /etc/passwd | sort -u ); do
          grep -q -P "^.*?:[^:]*:$i:" /etc/group
        if [ $? -ne 0 ]; then
          echo "Group $i is referenced by /etc/passwd but does not exist in /etc/group"
        fi
        done
      register: undefined_groups
      changed_when: false
      failed_when: false
    - name: ALL -> Report to user any unreferenced groups (fix manually if any)
      debug:
        msg: "{{ undefined_groups.stdout_lines }}"
      changed_when: true
      when: undefined_groups.stdout | trim | length > 0

- name: ALL -> Report on duplicate UIDs in /etc/passwd
  block:
    - name: ALL -> Use script to pull the list of duplicate UIDs
      shell: |
        cat /etc/passwd | cut -f3 -d":" | sort -n | uniq -c | while read x ; do
          [ -z "${x}" ] && break
          set - $x
          if [ $1 -gt 1 ]; then
            users=$(awk -F: '($3 == n) { print $1 }' n=$2 /etc/passwd | xargs)
            echo "Duplicate UID ($2): ${users}"
          fi
        done
      register: duplicate_uids
      changed_when: false
      failed_when: false
    - name: ALL -> Print report of duplicated UIDs to user (fix manually if any)
      debug:
        msg: "{{ duplicate_uids.stdout_lines }}"
      changed_when: true
      when: duplicate_uids.stdout | trim | length > 0

- name: ALL -> Report on duplicate GIDs in /etc/group
  block:
    - name: ALL -> Use script to pull the list of duplicate GIDs
      shell: |
        cat /etc/group | cut -f3 -d":" | sort -n | uniq -c | while read x ; do
          [ -z "${x}" ] && break
          set - $x
          if [ $1 -gt 1 ]; then
            groups=$(awk -F: '($3 == n) { print $1 }' n=$2 /etc/group | xargs)
            echo "Duplicate GID ($2): ${groups}"
          fi
        done
      register: duplicate_guids
      failed_when: false
      changed_when: false
    - name: ALL -> Print report of duplicate GIDs to user (fix manually if any)
      debug:
        msg: "{{ duplicate_guids.stdout_lines }}"
      changed_when: true
      when: duplicate_guids.stdout | trim | length > 0

- name: ALL -> Report on duplicate users in /etc/passwd
  block:
    - name: ALL -> Use script to pull the list of users
      shell: |
        cat /etc/passwd | cut -f1 -d":" | sort -n | uniq -c | while read x ; do
          [ -z "${x}" ] && break
          set - $x
          if [ $1 -gt 1 ]; then
            uids=$(awk -F: '($1 == n) { print $3 }' n=$2 /etc/passwd | xargs)
            echo "Duplicate User Name ($2): ${uids}"
          fi
        done
      register: duplicate_users
      changed_when: false
      failed_when: false
    - name: ALL -> Print report of duplicate users to user (fix manually if any)
      debug:
        msg: "{{ duplicate_users.stdout_lines }}"
      changed_when: true
      when: duplicate_users.stdout | trim | length > 0

- name: ALL -> Report on duplicate groups in /etc/group
  block:
    - name: ALL -> Use script to pull the list of groups
      shell: |
        cat /etc/group | cut -f1 -d":" | sort -n | uniq -c | while read x ; do
          [ -z "${x}" ] && break
          set - $x
          if [ $1 -gt 1 ]; then
            gids=$(awk -F: '($1 == n) { print $3 }' n=$2 /etc/passwd | xargs)
            echo "Duplicate Group Name ($2): ${gids}"
          fi
        done
      register: duplicate_groups
      failed_when: false
      changed_when: false
    - name: ALL -> Print report of duplicate groups to user (fix manually if any)
      debug:
        msg: "{{ duplicate_groups.stdout_lines }}"
      changed_when: true
      when: duplicate_groups.stdout | trim | length > 0

# Require rsyslog installed (done tags=COMMON_PACKAGES)
- name: ALL -> Setup RSYSLOG
  block:
    - name: ALL -> Ensure remote rsyslog messages are only accepted on designated log hosts
      block:
        - name: ALL -> Enable Rsyslog
          service:
            name: rsyslog
            enabled: yes
        - name: ALL -> Find all rsyslog conf files in /etc/rsyslog.d
          find:
            paths: "/etc/rsyslog.d"
            patterns: "*.conf"
            excludes: "CIS.conf"
          register: rsyslog_module_found
        - name: ALL -> Disable imtcp loading module on non log hosts (rsyslog.d conf files)
          lineinfile:
            dest: "{{ item.path }}"
            regexp: '^\$ModLoad\s+imtcp'
            state: absent
          loop: "{{ rsyslog_module_found.files }}"
        - name: ALL -> Disable imtcp loading module on non log hosts (main rsyslog conf file)
          lineinfile:
            dest: "/etc/rsyslog.conf"
            regexp: '^\$ModLoad\s+imtcp'
            state: absent
        - name: ALL -> Ensure rsyslog default file permissions are configured
          lineinfile:
            path: /etc/rsyslog.conf
            regexp: '^\$FileCreateMode\s+0640'
            line: "$FileCreateMode 0640"
            create: yes
            state: present
        - name: ALL -> Disable TCP port listening on non log hosts (rsylog.d conf files)
          lineinfile:
            dest: "{{ item.path }}"
            regexp: '^\$InputTCPServerRun'
            state: absent
          loop: "{{ rsyslog_module_found.files }}"
        - name: ALL -> Disable TCP port listening on non log hosts (main rsyslog conf file)
          lineinfile:
            dest: "/etc/rsyslog.conf"
            regexp: '^\$InputTCPServerRun'
            state: absent
        - name: ALL -> Enable loading of imtcp module on log hosts
          lineinfile:
            dest: /etc/rsyslog.d/CIS.conf
            regexp: '^\$ModLoad\s+imtcp'
            line: "$ModLoad imtcp"
            create: yes
            owner: root
            group: root
            mode: 0644
        - name: ALL -> Enable TCP Port listening on port {{ log_port }}
          lineinfile:
            dest: /etc/rsyslog.d/CIS.conf
            regexp: '^\$InputTCPServerRun {{ log_port }}'
            line: "$InputTCPServerRun {{ log_port }}"
            create: yes
            owner: root
            group: root
            mode: 0644
        - name: ALL -> Set address in rsyslog.conf
          lineinfile:
            dest: /etc/rsyslog.conf
            regexp: '^#\*.\* @@remote-host:514'
            line: "*.* @@{{ log_host }}:{{ log_port }}"
            backup: yes
            owner: root
            group: root
            mode: 0644
        - name: ALL -> Restart rsyslog server
          service:
            name: rsyslog
            state: restarted
            enabled: yes
          changed_when: false
      when: log_host is defined and log_host
    - name: ALL -> Find rsyslog files not owned by root and fix ownership
      block:
        - name: ALL -> Find rsyslog files not owned by root
          shell: |
            find $(cat /etc/rsyslog.conf /etc/rsyslog.d/*.conf | \
                 grep -v "#" | awk '{print $2}' | grep -v "^$" |grep "^\/" | grep log|grep -v "/etc/rsyslog.d") \
                 ! -user root 2>/dev/null
          register: nonroot_rsyslogs
          failed_when: false
          changed_when: false
        - name: ALL -> Report to user rsyslog files not owned by root if any
          debug: msg="{{ nonroot_rsyslogs.stdout_lines }}"
          when: nonroot_rsyslogs.stdout | length > 0
        - name: ALL -> Change ownership of file to root
          file:
            path: "{{ item }}"
            owner: root
          loop: "{{ nonroot_rsyslogs.stdout_lines }}"
          when: nonroot_rsyslogs.stdout | length > 0
  tags: RSYSLOG

- name: ALL -> Ensure audit log files have mode 0600 and owned by root
  block:
    - name: ALL -> Find rsyslog log files from /etc/audit/auditd.conf
      shell: grep "^log_file" /etc/audit/auditd.conf | awk '{print $3}'
      register: audit_logs
      failed_when: false
      changed_when: false
    - name: ALL -> Change ownership and mode of file to root and 600
      file:
        path: "{{ item }}"
        owner: root
        mode: "0600"
      loop: "{{ audit_logs.stdout_lines }}"
      when: audit_logs.stdout | length > 0
      failed_when: false
    - name: ALL -> Find rsyslog log folder from /etc/audit/auditd.conf
      command: dirname "{{ audit_logs.stdout_lines }}"
      register: audit_logs_folder
      failed_when: false
      changed_when: false
    - name: ALL -> Change ownership and mode of folder to root and 644
      file:
        path: "{{ item }}"
        owner: root
        mode: "0644"
        state: directory
      loop: "{{ audit_logs_folder.stdout_lines }}"
      when: audit_logs_folder.stdout | length > 0

- name: ALL -> USB mass storage must be disabled
  copy:
    dest: "/etc/modprobe.d/blacklist.conf"
    mode: '0644'
    content: |
       blacklist usb-storage

- name: ALL -> The system must not have unnecessary accounts and remove trails
  block:
    - name: ALL -> The system must not have unnecessary accounts
      user:
        name: "{{ item }}"
        state: absent
      loop:
        - games
        - news
        - gopher
        - lp
        - shutdown
        - halt
        - reboot
    - name: ALL -> Remove ftp system accounts if system is not FTP server
      user:
        name: "{{ item }}"
        state: absent
      loop:
        - ftp
        - ftpsecure
      when: not system_is_ftp
    - name: ALL -> Delete default unowned files after removal of unneeded accounts
      file:
        path: "{{ item }}"
        state: absent
      with_items:
        - /run/cups/certs
        - /var/cache/cups
        - /var/lib/news
        - /var/log/cups
        - /var/log/news
        - /var/log/news/news.crit
        - /var/log/news/news.err
        - /var/log/news/news.notice

- name: ALL -> Check does anyone else except root having a UID 0
  block:
    - name: ALL -> Check does anyone else except root having a UID 0
      shell: |
        awk -F: '($3 == "0") {print}' /etc/passwd | grep -v root
      failed_when: false
      changed_when: false
      register: uuid_root
    - name: ALL -> Report to user other accounts except root with uuid 0 - FIX THIS MANUALLY
      debug: msg="{{ uuid_root.stdout }}"
      when: uuid_root.stdout | length > 0
      changed_when: true

- name: ALL -> All user home directories must have mode 0750 or less permissive
  block:
    - name: ALL -> Get list of candidates for chmod 700 /home/dirs
      shell: |
        find /home -maxdepth 1 -mindepth 1 -type d -perm /0077
      register: home_to_0700
      changed_when: false
    - name: ALL -> List candidates for chmod 700 /home/dirs, if any
      debug:
        msg: "Candidate(s) for chmod 700 --> {{ home_to_0700.stdout_lines }}"
      when: home_to_0700.stdout | length > 0
      changed_when: home_to_0700.stdout | length > 0
    - name: ALL -> CHMOD 0700 for candidates (if they exists)
      shell: |
        find /home -maxdepth 1 -mindepth 1 -type d \
        -exec chmod 0700 {} \;
      when: home_to_0700.stdout | length > 0
      changed_when: home_to_0700.stdout | length > 0
    - name: ALL -> Set a+x for /home
      file:
        path: /home
        mode: 'a+x'

- name: ALL -> Find and report .shost and .equiv files on the system
  block:
    - name: ALL -> Remove /etc/hosts.equiv if exists
      file:
        path: /etc/hosts.equiv
        state: absent
    - name: ALL -> Find other .shost and .equiv files on the system
      shell: |
        find / -mount -type f -name "*.shost" -o -name "*.equiv"
      failed_when: false
      changed_when: false
      register: find_shost
    - name: ALL -> Report shosts file to user - FIX THIS MANUALLY
      debug: msg="{{ find_shost.stdout_lines }}"
      when: find_shost.stdout | length > 0
      changed_when: true

- name: ALL -> Setup banners
  block:
    - name: ALL -> Install motd banners
      copy:
        src: files/motd
        dest: /etc/motd
        owner: root
        group: root
        mode: 0644
    - name: ALL -> Install issue banners
      copy:
        dest: /etc/issue
        content: |
          Legal Notice: Unauthorized access and use of this system is strictly
          prohibited and can result in civil and criminal penalties.
          Authorized uses only. All activity may be monitored and reported.
        owner: root
        group: root
        mode: 0644
    - name: ALL -> Install issue.net banners
      copy:
        dest: /etc/issue.net
        content: |
          Legal Notice: Unauthorized access and use of this system is strictly
          prohibited and can result in civil and criminal penalties.
          Authorized uses only. All activity may be monitored and reported.
        owner: root
        group: root
        mode: 0644
    - name: ALL -> Set up the dconf profile for GDM
      blockinfile:
        path: /etc/dconf/profile/gdm
        owner: root
        group: root
        mode: 0644
        block: |
          user-db:user
          system-db:gdm
          file-db:/usr/share/gdm/greeter-dconf-defaults
      when: graphical_inteface is defined and graphical_interface
    - name: ALL -> Set GDM to use banner message
      blockinfile:
        path: /etc/dconf/db/gdm.d/01-banner-message
        owner: root
        group: root
        mode: 0644
        block: |
          [org/gnome/login-screen]
          banner-message-enable=true
          banner-message-text='Authorized uses only. All activity may be monitored and reported.'
      when: graphical_inteface is defined and graphical_interface

- name: ALL -> Folder /root to have 700
  file:
    path: "/root"
    owner: root
    group: root
    mode: "0700"
    state: directory

- name: ALL -> Users must provide a password for privilege escalation
  block:
    - name: ALL -> Find all sudoers files in /etc/sudoers.d
      find:
        paths: "/etc/sudoers.d"
      register: sudoers
    - name: ALL -> Remove NOPASSWD option from all files in /etc/sudoers.d
      replace:
        dest: "{{ item.path }}"
        regexp: 'NOPASSWD:'
        replace: ""
      with_items: "{{ sudoers.files }}"

- name: ALL -> CHMOD 0000 --> shadow, gshadow, passwd-, shadow-, group-
  block:
    - name: ALL -> Ensure permissions on shadow, gshadow, passwd-, shadow-, group-
      file:
        path: "{{ item }}"
        owner: root
        group: root
        mode: 0000
      loop:
        - /etc/shadow
        - /etc/gshadow
        - /etc/gshadow-
        - /etc/passwd-
        - /etc/shadow-
        - /etc/group-
      failed_when: false

- name: ALL -> CHMOD 0644 --> /etc/passwd /etc/group
  file:
    path: "{{ item }}"
    owner: root
    group: root
    mode: 0644
  loop:
    - /etc/passwd
    - /etc/group

- name: ALL -> Copy RKHUNTER to server
  block:
    - name: ALL -> Check does rkhunter exists
      shell: |
        /usr/local/bin/rkhunter -V
      register: rkhunter_out
      failed_when: false
      changed_when: false
    - name: ALL -> Extract rkhunter.tar.gz to /tmp
      unarchive:
        src: files/rkhunter/rkhunter.tar.gz
        dest: /tmp/
      when: rkhunter_out.rc > 0
    - name: ALL -> Install rkhunter
      shell: |
        cd /tmp/rkhunter-*
        bash installer.sh --install
        rm -rf /tmp/rkhunter-*
      when: rkhunter_out.rc > 0
    - name: ALL -> Create a symbolic link /bin/rkhunter
      file:
        src: /usr/local/bin/rkhunter
        dest: /bin/rkhunter
        owner: root
        group: root
        state: link
      when: rkhunter_out.rc > 0
  tags: RKHUNTER

- name: ALL -> Set single user password
  block:
    - name: ALL -> Set single user password
      replace:
        dest: /usr/lib/systemd/system/{{ item }}
        regexp: '^ExecStart=-((?!/bin/sh\s+-c\s+\"\s+/sbin/sulogin).)*'
        replace: "ExecStart=-/bin/sh -c \"/sbin/sulogin; /usr/bin/systemctl --fail --no-block default\""
      with_items:
        - rescue.service
        - emergency.service

- name: ALL -> The x86 Ctrl-Alt-Delete key sequence must be disabled
  systemd:
    name: ctrl-alt-del.target
    masked: yes
    state: stopped
    enabled: no

- name: ALL -> Configure system auditing
  block:
    - name: ALL -> Setup audit
      block:
        - name: ALL -> Configure audit log storage size
          replace:
            path: /etc/audit/auditd.conf
            regexp: "{{ item.find }}"
            replace: "{{ item.replace }}"
          loop:
            - { find: '^max_log_file\s+=\s+[^8]', replace: 'max_log_file = 8'}
            - { find: '^max_log_file_action\s+=\s+((?!keep_logs).)*$', replace: 'max_log_file_action = keep_logs' }
            - { find: '^space_left_action\s+=\s+((?!email).)*$', replace: 'space_left_action = email' }
            - { find: '^action_mail_acct\s+=\s+((?!root).)*$', replace: 'action_mail_acct = root' }
            - { find: '^admin_space_left_action\s+=\s+((?!suspend).)*$', replace: 'admin_space_left_action = suspend' }
        - name: ALL -> Ensure auditing for processes that start prior to auditd
          lineinfile:
            path: /etc/default/grub
            regexp: '^\s*GRUB_CMDLINE_LINUX.*audit=1'
            state: absent
          check_mode: yes
          changed_when: false
          register: audit_exist
          failed_when: false
        - name: ALL -> Enable audit service in grub
          replace:
            path: /etc/default/grub
            regexp: '^GRUB_CMDLINE_LINUX="'
            replace: 'GRUB_CMDLINE_LINUX="audit=1 '
          register: grub_has_changed
          when: audit_exist.changed
        - name: ALL -> Rebuild grub
          command: /usr/sbin/grub2-mkconfig -o /boot/grub2/grub.cfg
          when: grub_has_changed.changed
        - name: ALL -> Ensure to collect events that modify date/time
          template:
            dest: /etc/audit/rules.d/datetime.rules
            src: files/aurules/datetime.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Ensure events that modify user/group information are collected
          template:
            dest: /etc/audit/rules.d/user-group-info.rules
            src: files/aurules/user-group-info.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Ensure to collect events that modify network
          template:
            dest: /etc/audit/rules.d/network.rules
            src: files/aurules/network.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Ensure system logins are collected
          template:
            dest: /etc/audit/rules.d/login.rules
            src: files/aurules/login.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Ensure session initiation information is collected
          template:
            dest: /etc/audit/rules.d/sessions.rules
            src: files/aurules/sessions.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Determine the Minimum UID for new, non-system, accounts
          command: "/usr/bin/awk '/^s*UID_MIN/{print $2}' /etc/login.defs"
          register: min_uid
          changed_when: min_uid.rc == "2"
        - name: ALL -> Ensure modifications to discretionary access controls are collected
          template:
            dest: /etc/audit/rules.d/dac.rules
            src: files/aurules/dac.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Ensure unsuccessful unauthorized file access attempts are collected
          template:
            dest: /etc/audit/rules.d/bad-file-access.rules
            content:
            src: files/aurules/bad-file-access.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Ensure successful file system mounts are collected
          template:
            dest: /etc/audit/rules.d/file-system-mounts.rules
            src: files/aurules/file-system-mounts.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Ensure file deletion events by users are collected
          template:
            dest: /etc/audit/rules.d/delete.rules
            src: files/aurules/delete.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Set sudoer log
          set_fact:
            sudo_log: '/var/log/sudoers'
        - name: ALL -> Ensure sysadmin actions (sudolog) are collected
          template:
            dest: /etc/audit/rules.d/sudolog.rules
            src: files/aurules/sudolog.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Ensure kernel module loading and unloading is collected
          template:
            dest: /etc/audit/rules.d/modules.rules
            src: files/aurules/modules.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Ensure audit configuration is immutable
          copy:
            dest: /etc/audit/rules.d/99-finalize.rules
            content: |
              -e 2
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Custom audit rules
          copy:
            dest: /etc/audit/rules.d/audit.rules
            src: files/aurules/{{ ansible_os_family }}-audit.rules
            owner: root
            group: root
            mode: 0600
        - name: ALL -> Restart auditd
          service:
            name: auditd
            state: started
            enabled: yes

- name: ALL -> Audit log files on a regular basis
  block:
      #CHMOD 0640 setup #######################################################
    - name: ALL -> CHMOD 0640 - List candidate files in /var/log
      shell: |
        find /var/log        -type f -perm /0137 -name "boot.log" 2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "messages" 2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "syslog*"  2>/dev/null; \
        find /var/log/syslog -type f -perm /0137                  2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "auth.log" 2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "secure"   2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "dmesg"    2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "kern.log" 2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "faillog"  2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "cron"     2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "yum.log"  2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "mail*"    2>/dev/null; \
        find /var/log/httpd  -type f -perm /0137                  2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "mysql*"   2>/dev/null; \
        find /var/log        -type f -perm /0137 -name "apache*"  2>/dev/null
      register: candidates_0640
      changed_when: false
    - name: ALL -> CHMOD 0640 - Report candidate files in /var/log
      debug:
        msg: "{{ candidates_0640.stdout_lines }}"
      when: candidates_0640.stdout | length > 0
      changed_when: candidates_0640.stdout | length > 0
    - name: ALL -> CHMOD 0640 - Setup 0640 for candidate files in /var/log
      file:
        path: "{{ item }}"
        mode: '0640'
      with_items: "{{ candidates_0640.stdout_lines }}"
      when: candidates_0640.stdout | length > 0
      # CHMOD 0660 setup ######################################################
    - name: ALL -> CHMOD 0660 - List candidate files in /var/log (pacemaker, nsclient)
      shell: |
        find /var/log -type f -perm /0117 -name "pacemaker.log"   2>/dev/null; \
        find /var/log -type f -perm /0117 -name "pacemaker.log-*" 2>/dev/null; \
        find /var/log -type f -perm /0117 -name "nsclient.log*"   2>/dev/null
      register: candidates_0660
      changed_when: false
    - name: ALL -> CHMOD 0660 - Report candidate files (pacemaker, nsclient)
      debug:
        msg: "{{ candidates_0660.stdout_lines }}"
      when: candidates_0660.stdout | length > 0
      changed_when: candidates_0660.stdout | length > 0
    - name: ALL -> CHMOD 0660 - Setup 0660 for candidate files in /var/log (pacemaker, nsclient)
      file:
        path: "{{ item }}"
        mode: '0660'
      with_items: "{{ candidates_0660.stdout_lines }}"
      when: candidates_0660.stdout | length > 0
      # CHMOD 0733 setup ######################################################
    - name: ALL -> CHMOD 0733 - Check folder /var/log/sudosh
      shell: |
        find /var/log -type d -perm /0044 -name "sudosh" 2>/dev/null
      register: candidates_0733
      changed_when: false
    - name: ALL -> CHMOD 0733 - Report folder /var/log/sudosh
      debug:
        msg: "{{ candidates_0733.stdout_lines }}"
      when: candidates_0733.stdout | length > 0
      changed_when: candidates_0733.stdout | length > 0
    - name: ALL -> CHMOD 0733 - Setup 0733 for folder /var/log/sudosh
      file:
        path: "{{ item }}"
        mode: '0733'
      with_items: "{{ candidates_0733.stdout_lines }}"
      when: candidates_0733.stdout | length > 0
      # CHMOD 0664 setup ######################################################
    - name: ALL -> CHMOD 0664 - Check file /var/log/wtmp
      shell: |
        find /var/log -type f -perm /0113 -name "wtmp" 2>/dev/null
      register: candidates_0664
      changed_when: false
    - name: ALL -> CHMOD 0664 - Report file /var/log/wtmp
      debug:
        msg: "{{ candidates_0664.stdout_lines }}"
      when: candidates_0664.stdout | length > 0
      changed_when: candidates_0664.stdout | length > 0
    - name: ALL -> CHMOD 0644 - Setup 0664 for file /var/log/wtmp
      file:
        path: "{{ item }}"
        mode: '0664'
      with_items: "{{ candidates_0664.stdout_lines }}"
      when: candidates_0664.stdout | length > 0
  tags: AUDIT_LOG_FILES